{
  "version": 3,
  "sources": ["../src/tileRenderer.ts", "../src/tilingEngine.ts", "../src/index.ts"],
  "sourcesContent": ["import type { Tile } from \"./tilingEngine\";\n\nconst COLORS = [\"silver\", \"gray\"];\n\nexport const renderTiles = (\n  tiles: Array<Tile>,\n  context: CanvasRenderingContext2D,\n  cellSize: number\n) => {\n  context.clearRect(0, 0, context.canvas.width, context.canvas.height);\n  tiles.forEach((tile) => renderTile(tile, context, cellSize));\n};\n\nconst renderTile = (\n  tile: Tile,\n  context: CanvasRenderingContext2D,\n  cellSize: number\n) => {\n  const minX = Math.min(tile.tilePosition[0].x, tile.tilePosition[1].x);\n  const minY = Math.min(tile.tilePosition[0].y, tile.tilePosition[1].y);\n  const maxX = Math.max(tile.tilePosition[0].x, tile.tilePosition[1].x);\n  const maxY = Math.max(tile.tilePosition[0].y, tile.tilePosition[1].y);\n\n  const topLeft = { x: minX * cellSize, y: minY * cellSize };\n  const bottomRight = {\n    x: maxX * cellSize + cellSize,\n    y: maxY * cellSize + cellSize,\n  };\n\n  context.lineWidth = 2;\n  context.beginPath();\n  context.roundRect(\n    topLeft.x,\n    topLeft.y,\n    bottomRight.x - topLeft.x,\n    bottomRight.y - topLeft.y,\n    10\n  );\n  context.fillStyle = COLORS[tile.id % COLORS.length];\n  context.fill();\n  context.strokeStyle = \"black\";\n  context.stroke();\n};\n", "class Position {\n  constructor(public x: number, public y: number) {}\n  isEqual(other: Position): boolean {\n    return this.x === other.x && this.y === other.y;\n  }\n}\n\nexport class Tile {\n  constructor(\n    public tilePosition: [Position, Position],\n    public id: number = Math.floor(Math.random() * 32)\n  ) {}\n  overlaps(other: Tile): boolean {\n    return other.tilePosition.some((a) =>\n      this.tilePosition.some((b) => b.isEqual(a))\n    );\n  }\n}\n\nclass Tiling {\n  constructor(\n    public width: number,\n    public height: number,\n    public tiles: Array<Tile>\n  ) {}\n\n  occupiedPositions(): Array<Position> {\n    return this.tiles.flatMap((tile) => tile.tilePosition);\n  }\n\n  isInBounds(position: Position): boolean {\n    return (\n      position.x >= 0 &&\n      position.x < this.width &&\n      position.y >= 0 &&\n      position.y < this.height\n    );\n  }\n\n  isFreePosition(position: Position): boolean {\n    return (\n      this.isInBounds(position) &&\n      !this.occupiedPositions().some((p) => p.isEqual(position))\n    );\n  }\n\n  freePositions(): Array<Position> {\n    const positions: Array<Position> = [];\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n        const newPosition = new Position(x, y);\n        if (this.isFreePosition(newPosition)) {\n          positions.push(newPosition);\n        }\n      }\n    }\n    return positions;\n  }\n\n  /**\n   * A tiling is complete when every position is occupied\n   */\n  isComplete(): boolean {\n    return this.occupiedPositions().length === this.width * this.height;\n  }\n\n  /**\n   * The set of free positions is connected.\n   *\n   * Notably we consider the empty set to be connected.\n   */\n  hasConnectedVacancy(): boolean {\n    const freePositions = this.freePositions();\n    if (freePositions.length === 0) {\n      return true;\n    }\n\n    // Flood fill from the first free position\n    const toVisit = [freePositions[0]];\n    const visited: Array<Position> = [];\n\n    while (toVisit.length > 0) {\n      const current = toVisit.pop()!;\n      if (visited.some((p) => p.isEqual(current))) {\n        continue;\n      }\n      visited.push(current);\n\n      // Add all 4 neighboring positions\n      const neighbors = [\n        new Position(current.x - 1, current.y),\n        new Position(current.x + 1, current.y),\n        new Position(current.x, current.y - 1),\n        new Position(current.x, current.y + 1),\n      ];\n      for (const neighbor of neighbors) {\n        if (\n          freePositions.some((p) => p.isEqual(neighbor)) &&\n          !visited.some((p) => p.isEqual(neighbor))\n        ) {\n          toVisit.push(neighbor);\n        }\n      }\n    }\n\n    return visited.length === freePositions.length;\n  }\n\n  /**\n   * Walk one step down the tree of possible tilings\n   */\n  generateChildren(): Array<Tiling> {\n    // Find the most tightly controlled position\n    // We should generate only as many children as we have choices at the most tightly controlled position\n    const freePositions = this.freePositions()\n      // We do a little shuffle here to ensure we get different results each time\n      .map((value) => ({ value, rank: Math.random() }))\n      .toSorted((a, b) => a.rank - b.rank)\n      .map(({ value }) => value);\n    if (freePositions.length === 0) {\n      return [];\n    }\n\n    // Find the position with the fewest free neighbours\n    let bestPosition: Position | null = null;\n    let bestFreeNeighbours: Array<Position> = [];\n    for (const position of freePositions) {\n      const freeNeighbours = [\n        new Position(position.x - 1, position.y),\n        new Position(position.x + 1, position.y),\n        new Position(position.x, position.y - 1),\n        new Position(position.x, position.y + 1),\n      ].filter((neighbour) => this.isFreePosition(neighbour));\n\n      if (\n        bestPosition === null ||\n        freeNeighbours.length < bestFreeNeighbours.length\n      ) {\n        bestPosition = position;\n        bestFreeNeighbours = freeNeighbours;\n      }\n    }\n\n    return bestFreeNeighbours.map((neighbour) => {\n      const newTile = new Tile([bestPosition!, neighbour]);\n      return new Tiling(this.width, this.height, [...this.tiles, newTile]);\n    });\n  }\n}\n\nclass TileTreeWalkNode {\n  constructor(\n    // Null for root\n    public parent: TileTreeWalkNode | null,\n    // Tiles placed so far\n    public tiling: Tiling,\n    // Each child differs by one additional tile\n    public children: Array<TileTreeWalkNode> = [],\n    // Whether we have already explored this node\n    public visited: boolean = false,\n    // Whether this node can possibly lead to a solution\n    public viable: boolean = true\n  ) {}\n}\n\nexport function* initTileGenerator(\n  width: number,\n  height: number\n): Generator<Array<Tile>, Array<Tile>, unknown> {\n  const root = new TileTreeWalkNode(null, new Tiling(width, height, []));\n  let pointer = root;\n  yield pointer.tiling.tiles;\n\n  while (!pointer.tiling.isComplete()) {\n    // Yield the current pointer state\n\n    if (!pointer.viable) {\n      // Backtrack to parent\n      pointer = pointer.parent!;\n      yield pointer.tiling.tiles;\n\n      if (!pointer) {\n        throw new Error(\"No complete tiling found\");\n      }\n\n      // Accelerate backtracking until we find a node with connected vacancy\n      let hasConnectedVacancy = pointer.tiling.hasConnectedVacancy();\n      while (!hasConnectedVacancy) {\n        // Backtrack to parent\n        pointer.viable = false;\n        pointer = pointer.parent!;\n        yield pointer.tiling.tiles;\n        if (!pointer) {\n          throw new Error(\"No complete tiling found\");\n        }\n        hasConnectedVacancy = pointer.tiling.hasConnectedVacancy();\n      }\n    }\n\n    // Generate children if we haven't already visited this node\n    if (!pointer.visited) {\n      pointer.children = pointer.tiling\n        .generateChildren()\n        .map((tiling) => new TileTreeWalkNode(pointer, tiling));\n      pointer.visited = true;\n    }\n\n    const viableChildren = pointer.children.filter((child) => child.viable);\n    if (viableChildren.length === 0) {\n      // We found no way to proceed. This is a deadend.\n      pointer.viable = false;\n      // Return to loop top\n      continue;\n    }\n\n    // Randomly pick a viable child\n    pointer = viableChildren[Math.floor(Math.random() * viableChildren.length)];\n    yield pointer.tiling.tiles;\n  }\n\n  // We have found a complete tiling\n  return pointer.tiling.tiles;\n}\n", "import { renderTiles } from \"./tileRenderer\";\nimport { initTileGenerator } from \"./tilingEngine\";\n\nconst generateButton = document.getElementById(\"generate-button\")!;\nconst canvasElement = document.querySelector(\"canvas\")!;\nconst canvasContext = canvasElement.getContext(\"2d\")!;\n\nlet currentController: AbortController | null = null;\n\nconst CANVAS_SIZE = 1000; // Must match what we see in the HTML\nconst GRID_SIZE = 30; // Logical with and height of positions\nconst CELL_SIZE = CANVAS_SIZE / GRID_SIZE; // Size of a cell given the number of cells\n\nconst paintRandomTiles = async () => {\n  // Cancel any existing operation\n  if (currentController) {\n    currentController.abort();\n  }\n\n  // Create new controller for this operation\n  currentController = new AbortController();\n  const signal = currentController.signal;\n\n  try {\n    const tileGenerator = initTileGenerator(GRID_SIZE, GRID_SIZE);\n    let result = tileGenerator.next();\n    renderTiles(result.value, canvasContext, CELL_SIZE);\n\n    while (!result.done) {\n      // Check if operation was cancelled\n      if (signal.aborted) {\n        return;\n      }\n\n      await new Promise((resolve, reject) => {\n        const timeoutId = setTimeout(resolve, 1);\n        signal.addEventListener(\"abort\", () => {\n          clearTimeout(timeoutId);\n          reject(new DOMException(\"Operation cancelled\", \"AbortError\"));\n        });\n      });\n\n      result = tileGenerator.next();\n      renderTiles(result.value, canvasContext, CELL_SIZE);\n    }\n  } catch (error) {\n    if (error instanceof DOMException && error.name === \"AbortError\") {\n      // Operation was cancelled, this is expected\n      return;\n    }\n    // Re-throw other errors\n    throw error;\n  }\n};\n\ngenerateButton.addEventListener(\"click\", paintRandomTiles);\npaintRandomTiles();\n"],
  "mappings": "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",
  "names": ["COLORS", "renderTiles", "tiles", "context", "cellSize", "tile", "renderTile", "minX", "minY", "maxX", "maxY", "topLeft", "bottomRight", "Position", "x", "y", "other", "Tile", "tilePosition", "id", "a", "b", "Tiling", "_Tiling", "width", "height", "tiles", "tile", "position", "p", "positions", "newPosition", "freePositions", "toVisit", "visited", "current", "neighbors", "neighbor", "value", "bestPosition", "bestFreeNeighbours", "freeNeighbours", "neighbour", "newTile", "TileTreeWalkNode", "parent", "tiling", "children", "viable", "initTileGenerator", "pointer", "hasConnectedVacancy", "viableChildren", "child", "generateButton", "canvasElement", "canvasContext", "currentController", "CANVAS_SIZE", "GRID_SIZE", "CELL_SIZE", "paintRandomTiles", "signal", "tileGenerator", "initTileGenerator", "result", "renderTiles", "resolve", "reject", "timeoutId", "error"]
}
