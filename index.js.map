{
  "version": 3,
  "sources": ["../src/tileRenderer.ts", "../src/tilingEngine.ts", "../src/index.ts"],
  "sourcesContent": ["import type { Tile } from \"./tilingEngine\";\n\nexport const renderTiles = (\n  tiles: Array<Tile>,\n  context: CanvasRenderingContext2D\n) => {\n  tiles.forEach((tile) => renderTile(tile, context));\n};\n\nconst renderTile = (\n  tile: Tile,\n  context: CanvasRenderingContext2D\n) => {\n  const minX = Math.min(tile.tilePosition[0].x, tile.tilePosition[1].x);\n  const minY = Math.min(tile.tilePosition[0].y, tile.tilePosition[1].y);\n  const maxX = Math.max(tile.tilePosition[0].x, tile.tilePosition[1].x);\n  const maxY = Math.max(tile.tilePosition[0].y, tile.tilePosition[1].y);\n\n  const topLeft = { x: minX * 100, y: minY * 100 };\n  const bottomRight = { x: maxX * 100 + 100, y: maxY * 100 + 100 };\n\n  context.strokeStyle = \"black\";\n  context.lineWidth = 2;\n  context.beginPath();\n  context.roundRect(\n    topLeft.x,\n    topLeft.y,\n    bottomRight.x - topLeft.x,\n    bottomRight.y - topLeft.y,\n    10\n  );\n  context.fillStyle = \"rgba(0, 0, 0, 0.34)\";\n  context.fill();\n  context.stroke();\n};\n", "class Position {\n  constructor(public x: number, public y: number) {}\n  isEqual(other: Position): boolean {\n    return this.x === other.x && this.y === other.y;\n  }\n}\n\nexport class Tile {\n  constructor(public tilePosition: [Position, Position]) {}\n  overlaps(other: Tile): boolean {\n    const [a, b] = this.tilePosition;\n    return other.tilePosition.some((pos) => a.isEqual(pos) || b.isEqual(pos));\n  }\n}\n\nclass Tiling {\n  constructor(\n    public width: number,\n    public height: number,\n    public tiles: Array<Tile>\n  ) {}\n\n  /**\n   * Is the given tile a valid addition to this tiling?\n   */\n  canPlaceTile(newTile: Tile): boolean {\n    // We can place a tile if it doesn't overlap existing tiles\n    const hasOverlap = this.tiles.some((existingTile) =>\n      newTile.overlaps(existingTile)\n    );\n\n    // And if it's within bounds\n    const withinBounds = newTile.tilePosition.every(\n      (pos) =>\n        pos.x >= 0 && pos.x < this.width && pos.y >= 0 && pos.y < this.height\n    );\n\n    return !hasOverlap && withinBounds;\n  }\n\n  /**\n   * Walk one step down the tree of possible tilings\n   */\n  generateChildren(): Array<Tiling> {\n    // Find the most tightly controlled position\n    // We should generate only as many children as we have choices at the most tightly controlled position\n    const freePositions = this.freePositions();\n    if (freePositions.length === 0) {\n      return [];\n    }\n\n    // Find the position with the fewest free neighbours\n    let bestPosition: Position | null = null;\n    let bestFreeNeighbours: Array<Position> = [];\n    for (const position of freePositions) {\n      const freeNeighbours = [\n        new Position(position.x - 1, position.y),\n        new Position(position.x + 1, position.y),\n        new Position(position.x, position.y - 1),\n        new Position(position.x, position.y + 1),\n      ].filter((neighbour) => this.isFreePosition(neighbour));\n\n      if (\n        bestPosition === null ||\n        freeNeighbours.length < bestFreeNeighbours.length\n      ) {\n        bestPosition = position;\n        bestFreeNeighbours = freeNeighbours;\n      }\n    }\n\n    return bestFreeNeighbours.map((neighbour) => {\n      const newTile = new Tile([bestPosition!, neighbour]);\n      if (!this.canPlaceTile(newTile)) {\n        throw new Error(\"Logic error: cannot place tile\");\n      }\n      return new Tiling(this.width, this.height, [...this.tiles, newTile]);\n    });\n  }\n\n  occupiedPositions(): Array<Position> {\n    return this.tiles.flatMap((tile) => tile.tilePosition);\n  }\n\n  isInBounds(position: Position): boolean {\n    return (\n      position.x >= 0 &&\n      position.x < this.width &&\n      position.y >= 0 &&\n      position.y < this.height\n    );\n  }\n\n  isFreePosition(position: Position): boolean {\n    return this.isInBounds(position) && !this.occupiedPositions().some((p) => p.isEqual(position));\n  }\n\n  freePositions(): Array<Position> {\n    const positions: Array<Position> = [];\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n        const newPosition = new Position(x, y);\n        if (this.isFreePosition(newPosition)) {\n          positions.push(newPosition);\n        }\n      }\n    }\n    return positions;\n  }\n\n  /**\n   * A tiling is complete when every position is occupied\n   */\n  isComplete(): boolean {\n    return this.occupiedPositions().length === this.width * this.height;\n  }\n\n  /**\n   * If everything is working correctly, this always returns false.\n   * But it is useful for debugging.\n   */\n  hasOverlaps(): boolean {\n    for (let i = 0; i < this.tiles.length; i++) {\n      for (let j = i + 1; j < this.tiles.length; j++) {\n        if (this.tiles[i].overlaps(this.tiles[j])) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n\nclass TileTreeWalkNode {\n  constructor(\n    // // Null for root\n    public parent: TileTreeWalkNode | null,\n    // // Tiles placed so far\n    public tiling: Tiling,\n    // // Each child differs by one additional tile\n    public children: Array<TileTreeWalkNode> = [],\n    // // Whether we have already explored this node\n    public visited: boolean = false,\n    // // Whether this node can possibly lead to a solution\n    public viable: boolean = true\n  ) {}\n  countVisited(): number {\n    return (\n      (this.visited ? 1 : 0) +\n      this.children.reduce((sum, child) => sum + child.countVisited(), 0)\n    );\n  }\n  countViable(): number {\n    return (\n      (this.viable ? 1 : 0) +\n      this.children.reduce((sum, child) => sum + child.countViable(), 0)\n    );\n  }\n}\n\nexport const generateTiles = (): Array<Tile> => {\n  const root = new TileTreeWalkNode(null, new Tiling(10, 10, []));\n  let pointer = root;\n\n  while (!pointer.tiling.isComplete()) {\n    if (!pointer.viable) {\n      // Backtrack to parent\n      pointer = pointer.parent!;\n\n      if (!pointer) {\n        throw new Error(\"No complete tiling found\");\n      }\n    }\n\n    // Generate children if we haven't already visited this node\n    if (!pointer.visited) {\n      pointer.children = pointer.tiling\n        .generateChildren()\n        .map((tiling) => new TileTreeWalkNode(pointer, tiling));\n      pointer.visited = true;\n    }\n\n    const viableChildren = pointer.children.filter((child) => child.viable);\n    if (viableChildren.length === 0) {\n      // We found no way to proceed. This is a deadend.\n      pointer.viable = false;\n      // Return to loop top\n      continue;\n    }\n\n    // Randomly pick a viable child\n    pointer = viableChildren[Math.floor(Math.random() * viableChildren.length)];\n  }\n\n  // We have found a complete tiling\n  return pointer.tiling.tiles;\n};\n", "import { renderTiles } from \"./tileRenderer\";\nimport { generateTiles } from \"./tilingEngine\";\n\nconst generateButton = document.getElementById(\"generate-button\")!;\nconst canvasElement = document.querySelector(\"canvas\")!;\nconst canvasContext = canvasElement.getContext(\"2d\")!;\n\nconst paintRandomTiles = () => {\n  canvasContext.clearRect(0, 0, canvasElement.width, canvasElement.height);\n  const tiles = generateTiles();\n  renderTiles(tiles, canvasContext);\n};\n\ngenerateButton.addEventListener(\"click\", paintRandomTiles);\npaintRandomTiles();\n"],
  "mappings": "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",
  "names": ["renderTiles", "tiles", "context", "tile", "renderTile", "minX", "minY", "maxX", "maxY", "topLeft", "bottomRight", "Position", "x", "y", "other", "Tile", "tilePosition", "a", "b", "pos", "Tiling", "_Tiling", "width", "height", "tiles", "newTile", "hasOverlap", "existingTile", "withinBounds", "freePositions", "bestPosition", "bestFreeNeighbours", "position", "freeNeighbours", "neighbour", "tile", "p", "positions", "newPosition", "j", "TileTreeWalkNode", "parent", "tiling", "children", "visited", "viable", "sum", "child", "generateTiles", "pointer", "viableChildren", "generateButton", "canvasElement", "canvasContext", "paintRandomTiles", "tiles", "generateTiles", "renderTiles"]
}
