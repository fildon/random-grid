{
  "version": 3,
  "sources": ["../src/tileRenderer.ts", "../src/tilingEngine.ts", "../src/index.ts"],
  "sourcesContent": ["import type { Tile } from \"./tilingEngine\";\n\nexport const renderTiles = (\n  tiles: Array<Tile>,\n  context: CanvasRenderingContext2D,\n  cellSize: number\n) => {\n  context.clearRect(0, 0, context.canvas.width, context.canvas.height);\n  tiles.forEach((tile) => renderTile(tile, context, cellSize));\n};\n\nconst renderTile = (\n  tile: Tile,\n  context: CanvasRenderingContext2D,\n  cellSize: number\n) => {\n  const minX = Math.min(tile.tilePosition[0].x, tile.tilePosition[1].x);\n  const minY = Math.min(tile.tilePosition[0].y, tile.tilePosition[1].y);\n  const maxX = Math.max(tile.tilePosition[0].x, tile.tilePosition[1].x);\n  const maxY = Math.max(tile.tilePosition[0].y, tile.tilePosition[1].y);\n\n  const topLeft = { x: minX * cellSize, y: minY * cellSize };\n  const bottomRight = { x: maxX * cellSize + cellSize, y: maxY * cellSize + cellSize };\n\n  context.strokeStyle = \"black\";\n  context.lineWidth = 2;\n  context.beginPath();\n  context.roundRect(\n    topLeft.x,\n    topLeft.y,\n    bottomRight.x - topLeft.x,\n    bottomRight.y - topLeft.y,\n    10\n  );\n  context.fillStyle = \"rgba(0, 0, 0, 0.34)\";\n  context.fill();\n  context.stroke();\n};\n", "class Position {\n  constructor(public x: number, public y: number) {}\n  isEqual(other: Position): boolean {\n    return this.x === other.x && this.y === other.y;\n  }\n}\n\nexport class Tile {\n  constructor(public tilePosition: [Position, Position]) {}\n  overlaps(other: Tile): boolean {\n    return other.tilePosition.some((a) => this.tilePosition.some((b) => b.isEqual(a)));\n  }\n}\n\nclass Tiling {\n  constructor(\n    public width: number,\n    public height: number,\n    public tiles: Array<Tile>\n  ) {}\n\n  occupiedPositions(): Array<Position> {\n    return this.tiles.flatMap((tile) => tile.tilePosition);\n  }\n\n  isInBounds(position: Position): boolean {\n    return (\n      position.x >= 0 &&\n      position.x < this.width &&\n      position.y >= 0 &&\n      position.y < this.height\n    );\n  }\n\n  isFreePosition(position: Position): boolean {\n    return (\n      this.isInBounds(position) &&\n      !this.occupiedPositions().some((p) => p.isEqual(position))\n    );\n  }\n\n  freePositions(): Array<Position> {\n    const positions: Array<Position> = [];\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n        const newPosition = new Position(x, y);\n        if (this.isFreePosition(newPosition)) {\n          positions.push(newPosition);\n        }\n      }\n    }\n    return positions;\n  }\n\n  /**\n   * A tiling is complete when every position is occupied\n   */\n  isComplete(): boolean {\n    return this.occupiedPositions().length === this.width * this.height;\n  }\n\n  /**\n   * Walk one step down the tree of possible tilings\n   */\n  generateChildren(): Array<Tiling> {\n    // Find the most tightly controlled position\n    // We should generate only as many children as we have choices at the most tightly controlled position\n    const freePositions = this.freePositions()\n      // We do a little shuffle here to ensure we get different results each time\n      .map(value => ({ value, rank: Math.random() }))\n      .toSorted((a, b) => a.rank - b.rank)\n      .map(({ value }) => value);\n    if (freePositions.length === 0) {\n      return [];\n    }\n\n    // Find the position with the fewest free neighbours\n    let bestPosition: Position | null = null;\n    let bestFreeNeighbours: Array<Position> = [];\n    for (const position of freePositions) {\n      const freeNeighbours = [\n        new Position(position.x - 1, position.y),\n        new Position(position.x + 1, position.y),\n        new Position(position.x, position.y - 1),\n        new Position(position.x, position.y + 1),\n      ].filter((neighbour) => this.isFreePosition(neighbour));\n\n      if (\n        bestPosition === null ||\n        freeNeighbours.length < bestFreeNeighbours.length\n      ) {\n        bestPosition = position;\n        bestFreeNeighbours = freeNeighbours;\n      }\n    }\n\n    return bestFreeNeighbours.map((neighbour) => {\n      const newTile = new Tile([bestPosition!, neighbour]);\n      return new Tiling(this.width, this.height, [...this.tiles, newTile]);\n    });\n  }\n}\n\nclass TileTreeWalkNode {\n  constructor(\n    // // Null for root\n    public parent: TileTreeWalkNode | null,\n    // // Tiles placed so far\n    public tiling: Tiling,\n    // // Each child differs by one additional tile\n    public children: Array<TileTreeWalkNode> = [],\n    // // Whether we have already explored this node\n    public visited: boolean = false,\n    // // Whether this node can possibly lead to a solution\n    public viable: boolean = true\n  ) {}\n}\n\nexport function* initTileGenerator(width: number, height: number): Generator<Array<Tile>, Array<Tile>, unknown> {\n  const root = new TileTreeWalkNode(null, new Tiling(width, height, []));\n  let pointer = root;\n\n  while (!pointer.tiling.isComplete()) {\n    // Yield the current pointer state\n    yield pointer.tiling.tiles;\n\n    if (!pointer.viable) {\n      // Backtrack to parent\n      pointer = pointer.parent!;\n\n      if (!pointer) {\n        throw new Error(\"No complete tiling found\");\n      }\n    }\n\n    // Generate children if we haven't already visited this node\n    if (!pointer.visited) {\n      pointer.children = pointer.tiling\n        .generateChildren()\n        .map((tiling) => new TileTreeWalkNode(pointer, tiling));\n      pointer.visited = true;\n    }\n\n    const viableChildren = pointer.children.filter((child) => child.viable);\n    if (viableChildren.length === 0) {\n      // We found no way to proceed. This is a deadend.\n      pointer.viable = false;\n      // Return to loop top\n      continue;\n    }\n\n    // Randomly pick a viable child\n    pointer = viableChildren[Math.floor(Math.random() * viableChildren.length)];\n  }\n\n  // We have found a complete tiling\n  return pointer.tiling.tiles;\n}\n", "import { renderTiles } from \"./tileRenderer\";\nimport { initTileGenerator } from \"./tilingEngine\";\n\nconst generateButton = document.getElementById(\"generate-button\")!;\nconst canvasElement = document.querySelector(\"canvas\")!;\nconst canvasContext = canvasElement.getContext(\"2d\")!;\n\nlet currentController: AbortController | null = null;\n\nconst CANVAS_SIZE = 1000; // Must match what we see in the HTML\nconst GRID_SIZE = 30; // Logical with and height of positions\nconst CELL_SIZE = CANVAS_SIZE / GRID_SIZE; // Size of a cell given the number of cells\n\nconst paintRandomTiles = async () => {\n  // Cancel any existing operation\n  if (currentController) {\n    currentController.abort();\n  }\n  \n  // Create new controller for this operation\n  currentController = new AbortController();\n  const signal = currentController.signal;\n  \n  try {\n    const tileGenerator = initTileGenerator(GRID_SIZE, GRID_SIZE);\n    let result = tileGenerator.next();\n    renderTiles(result.value, canvasContext, CELL_SIZE);\n    \n    while (!result.done) {\n      // Check if operation was cancelled\n      if (signal.aborted) {\n        return;\n      }\n      \n      await new Promise((resolve, reject) => {\n        const timeoutId = setTimeout(resolve, 1);\n        signal.addEventListener('abort', () => {\n          clearTimeout(timeoutId);\n          reject(new DOMException('Operation cancelled', 'AbortError'));\n        });\n      });\n      \n      result = tileGenerator.next();\n      renderTiles(result.value, canvasContext, CELL_SIZE);\n    }\n  } catch (error) {\n    if (error instanceof DOMException && error.name === 'AbortError') {\n      // Operation was cancelled, this is expected\n      return;\n    }\n    // Re-throw other errors\n    throw error;\n  }\n};\n\ngenerateButton.addEventListener(\"click\", paintRandomTiles);\npaintRandomTiles();\n\n"],
  "mappings": "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",
  "names": ["renderTiles", "tiles", "context", "cellSize", "tile", "renderTile", "minX", "minY", "maxX", "maxY", "topLeft", "bottomRight", "Position", "x", "y", "other", "Tile", "tilePosition", "a", "b", "Tiling", "_Tiling", "width", "height", "tiles", "tile", "position", "p", "positions", "newPosition", "freePositions", "value", "bestPosition", "bestFreeNeighbours", "freeNeighbours", "neighbour", "newTile", "TileTreeWalkNode", "parent", "tiling", "children", "visited", "viable", "initTileGenerator", "pointer", "viableChildren", "child", "generateButton", "canvasElement", "canvasContext", "currentController", "CANVAS_SIZE", "GRID_SIZE", "CELL_SIZE", "paintRandomTiles", "signal", "tileGenerator", "initTileGenerator", "result", "renderTiles", "resolve", "reject", "timeoutId", "error"]
}
