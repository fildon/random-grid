{
  "version": 3,
  "sources": ["../src/tileRenderer.ts", "../src/tilingEngine.ts", "../src/index.ts"],
  "sourcesContent": ["import type { Tile } from \"./tilingEngine\";\n\nexport const renderTiles = (\n  tiles: Array<Tile>,\n  context: CanvasRenderingContext2D\n) => {\n  tiles.forEach((tile) => renderTile(tile, context));\n};\n\nconst renderTile = (\n  tile: Tile,\n  context: CanvasRenderingContext2D\n) => {\n  const minX = Math.min(tile.tilePosition[0].x, tile.tilePosition[1].x);\n  const minY = Math.min(tile.tilePosition[0].y, tile.tilePosition[1].y);\n  const maxX = Math.max(tile.tilePosition[0].x, tile.tilePosition[1].x);\n  const maxY = Math.max(tile.tilePosition[0].y, tile.tilePosition[1].y);\n\n  const topLeft = { x: minX * 50, y: minY * 50 };\n  const bottomRight = { x: maxX * 50 + 50, y: maxY * 50 + 50 };\n\n  context.strokeStyle = \"black\";\n  context.lineWidth = 2;\n  context.beginPath();\n  context.roundRect(\n    topLeft.x,\n    topLeft.y,\n    bottomRight.x - topLeft.x,\n    bottomRight.y - topLeft.y,\n    10\n  );\n  context.fillStyle = \"rgba(0, 0, 0, 0.34)\";\n  context.fill();\n  context.stroke();\n};\n", "class Position {\n  constructor(public x: number, public y: number) {}\n  isEqual(other: Position): boolean {\n    return this.x === other.x && this.y === other.y;\n  }\n}\n\nexport class Tile {\n  constructor(public tilePosition: [Position, Position]) {}\n  overlaps(other: Tile): boolean {\n    return other.tilePosition.some((a) => this.tilePosition.some((b) => b.isEqual(a)));\n  }\n}\n\nclass Tiling {\n  constructor(\n    public width: number,\n    public height: number,\n    public tiles: Array<Tile>\n  ) {}\n\n  occupiedPositions(): Array<Position> {\n    return this.tiles.flatMap((tile) => tile.tilePosition);\n  }\n\n  isInBounds(position: Position): boolean {\n    return (\n      position.x >= 0 &&\n      position.x < this.width &&\n      position.y >= 0 &&\n      position.y < this.height\n    );\n  }\n\n  isFreePosition(position: Position): boolean {\n    return (\n      this.isInBounds(position) &&\n      !this.occupiedPositions().some((p) => p.isEqual(position))\n    );\n  }\n\n  freePositions(): Array<Position> {\n    const positions: Array<Position> = [];\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n        const newPosition = new Position(x, y);\n        if (this.isFreePosition(newPosition)) {\n          positions.push(newPosition);\n        }\n      }\n    }\n    return positions;\n  }\n\n  /**\n   * A tiling is complete when every position is occupied\n   */\n  isComplete(): boolean {\n    return this.occupiedPositions().length === this.width * this.height;\n  }\n\n  /**\n   * Walk one step down the tree of possible tilings\n   */\n  generateChildren(): Array<Tiling> {\n    // Find the most tightly controlled position\n    // We should generate only as many children as we have choices at the most tightly controlled position\n    const freePositions = this.freePositions();\n    if (freePositions.length === 0) {\n      return [];\n    }\n\n    // Find the position with the fewest free neighbours\n    let bestPosition: Position | null = null;\n    let bestFreeNeighbours: Array<Position> = [];\n    for (const position of freePositions) {\n      const freeNeighbours = [\n        new Position(position.x - 1, position.y),\n        new Position(position.x + 1, position.y),\n        new Position(position.x, position.y - 1),\n        new Position(position.x, position.y + 1),\n      ].filter((neighbour) => this.isFreePosition(neighbour));\n\n      if (\n        bestPosition === null ||\n        freeNeighbours.length < bestFreeNeighbours.length\n      ) {\n        bestPosition = position;\n        bestFreeNeighbours = freeNeighbours;\n      }\n    }\n\n    return bestFreeNeighbours.map((neighbour) => {\n      const newTile = new Tile([bestPosition!, neighbour]);\n      return new Tiling(this.width, this.height, [...this.tiles, newTile]);\n    });\n  }\n}\n\nclass TileTreeWalkNode {\n  constructor(\n    // // Null for root\n    public parent: TileTreeWalkNode | null,\n    // // Tiles placed so far\n    public tiling: Tiling,\n    // // Each child differs by one additional tile\n    public children: Array<TileTreeWalkNode> = [],\n    // // Whether we have already explored this node\n    public visited: boolean = false,\n    // // Whether this node can possibly lead to a solution\n    public viable: boolean = true\n  ) {}\n}\n\nexport const generateTiles = (): Array<Tile> => {\n  const root = new TileTreeWalkNode(null, new Tiling(20, 20, []));\n  let pointer = root;\n\n  while (!pointer.tiling.isComplete()) {\n    if (!pointer.viable) {\n      // Backtrack to parent\n      pointer = pointer.parent!;\n\n      if (!pointer) {\n        throw new Error(\"No complete tiling found\");\n      }\n    }\n\n    // Generate children if we haven't already visited this node\n    if (!pointer.visited) {\n      pointer.children = pointer.tiling\n        .generateChildren()\n        .map((tiling) => new TileTreeWalkNode(pointer, tiling));\n      pointer.visited = true;\n    }\n\n    const viableChildren = pointer.children.filter((child) => child.viable);\n    if (viableChildren.length === 0) {\n      // We found no way to proceed. This is a deadend.\n      pointer.viable = false;\n      // Return to loop top\n      continue;\n    }\n\n    // Randomly pick a viable child\n    pointer = viableChildren[Math.floor(Math.random() * viableChildren.length)];\n  }\n\n  // We have found a complete tiling\n  return pointer.tiling.tiles;\n};\n", "import { renderTiles } from \"./tileRenderer\";\nimport { generateTiles } from \"./tilingEngine\";\n\nconst generateButton = document.getElementById(\"generate-button\")!;\nconst canvasElement = document.querySelector(\"canvas\")!;\nconst canvasContext = canvasElement.getContext(\"2d\")!;\n\nconst paintRandomTiles = () => {\n  canvasContext.clearRect(0, 0, canvasElement.width, canvasElement.height);\n  const tiles = generateTiles();\n  renderTiles(tiles, canvasContext);\n};\n\ngenerateButton.addEventListener(\"click\", paintRandomTiles);\npaintRandomTiles();\n"],
  "mappings": "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",
  "names": ["renderTiles", "tiles", "context", "tile", "renderTile", "minX", "minY", "maxX", "maxY", "topLeft", "bottomRight", "Position", "x", "y", "other", "Tile", "tilePosition", "a", "b", "Tiling", "_Tiling", "width", "height", "tiles", "tile", "position", "p", "positions", "newPosition", "freePositions", "bestPosition", "bestFreeNeighbours", "freeNeighbours", "neighbour", "newTile", "TileTreeWalkNode", "parent", "tiling", "children", "visited", "viable", "generateTiles", "pointer", "viableChildren", "child", "generateButton", "canvasElement", "canvasContext", "paintRandomTiles", "tiles", "generateTiles", "renderTiles"]
}
